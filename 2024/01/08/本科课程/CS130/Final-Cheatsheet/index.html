<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>【CS130】Final Review | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Cheatsheet-Final4. Scheduling4.0. OverviewDefinitionScheduling：Deciding which threads are given access to resources from moment to moment.  Often, we think in terms of CPU time, but could also think a">
<meta property="og:type" content="article">
<meta property="og:title" content="【CS130】Final Review">
<meta property="og:url" content="http://example.com/2024/01/08/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/CS130/Final-Cheatsheet/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Cheatsheet-Final4. Scheduling4.0. OverviewDefinitionScheduling：Deciding which threads are given access to resources from moment to moment.  Often, we think in terms of CPU time, but could also think a">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet13.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet15.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet16.png">
<meta property="og:image" content="http://example.com/Cheatsheet-Final%20a3ede0b2d25945df9dd63986f8a9b2fb/Untitled%2017.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet19.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet20.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet22.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet23.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet24.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet26.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet27.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet28.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet29.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet30.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet31.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet32.png">
<meta property="article:published_time" content="2024-01-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-28T13:33:08.301Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="CourseReview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet0.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-本科课程/CS130/Final-Cheatsheet" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/08/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/CS130/Final-Cheatsheet/" class="article-date">
  <time class="dt-published" datetime="2024-01-07T16:00:00.000Z" itemprop="datePublished">2024-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/">本科课程</a>►<a class="article-category-link" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/CS130/">CS130</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      【CS130】Final Review
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Cheatsheet-Final"><a href="#Cheatsheet-Final" class="headerlink" title="Cheatsheet-Final"></a>Cheatsheet-Final</h1><h1 id="4-Scheduling"><a href="#4-Scheduling" class="headerlink" title="4. Scheduling"></a>4. Scheduling</h1><h2 id="4-0-Overview"><a href="#4-0-Overview" class="headerlink" title="4.0. Overview"></a>4.0. Overview</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>Scheduling：Deciding which threads are given access to resources from moment to moment.</p>
<ul>
<li>Often, we think in terms of CPU time, but could also think about access to resources like network BW or disk access.</li>
</ul>
<h3 id="Scheduling-Assumptions"><a href="#Scheduling-Assumptions" class="headerlink" title="Scheduling Assumptions"></a>Scheduling Assumptions</h3><ul>
<li>One program per user</li>
<li>One thread per program</li>
<li>Programs are independent</li>
</ul>
<h3 id="Scheduling-Policy-Goals-Criteria（调度的主要目的）"><a href="#Scheduling-Policy-Goals-Criteria（调度的主要目的）" class="headerlink" title="Scheduling Policy Goals &#x2F; Criteria（调度的主要目的）"></a>Scheduling Policy Goals &#x2F; Criteria（调度的主要目的）</h3><ul>
<li>Minimize Response Time（最小化响应时间）<ul>
<li>Minimize elapsed time to do an operation &#x2F; job</li>
</ul>
</li>
<li>Maximize Throughput（最大化吞吐量）<ul>
<li>Throughput related to response time, but not identical:<ul>
<li>Minimizing response time will lead to more context switching than if you only maximized throughput</li>
</ul>
</li>
<li>Two parts to maximizing throughput<ul>
<li>Minimize overhead（最小化调度的开销）</li>
<li>Efficient use of resources（最大化利用资源）</li>
</ul>
</li>
</ul>
</li>
<li>Fairness<ul>
<li>Share CPU among users in some equitable way</li>
</ul>
</li>
<li>程序既使用CPU，也使用I&#x2F;O设备。操作系统通过调度算法决定下一个要在CPU上执行的作业。时间片轮转调度算法确保每个线程都能获得一定的CPU时间。某些I&#x2F;O活动可能会被视为计算，因为CPU仍在使用中。I&#x2F;O指的是进程进入阻塞状态，等待外部设备完成工作。</li>
</ul>
<h3 id="Scheduling-Algorithms"><a href="#Scheduling-Algorithms" class="headerlink" title="Scheduling Algorithms"></a>Scheduling Algorithms</h3><ul>
<li>First Come, First Served</li>
<li>Round Robin</li>
<li>Priority</li>
<li>Multi Level Queue</li>
<li>Real-Time Scheduling</li>
</ul>
<h2 id="4-1-FCFS-Scheduling"><a href="#4-1-FCFS-Scheduling" class="headerlink" title="4.1. FCFS Scheduling"></a>4.1. FCFS Scheduling</h2><h3 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h3><ul>
<li><strong>First-Come, First Served</strong></li>
<li><strong>Convoy Effort</strong>: short process behind long process</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet0.png"><br><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet1.png"></p>
<h2 id="4-2-Round-Robin-Scheduling"><a href="#4-2-Round-Robin-Scheduling" class="headerlink" title="4.2. Round Robin Scheduling"></a>4.2. Round Robin Scheduling</h2><h3 id="Ideas-1"><a href="#Ideas-1" class="headerlink" title="Ideas"></a>Ideas</h3><ul>
<li>Idea：Preemption<ul>
<li>Each process gets a small unit of CPU time quantum, usually 10-100ms</li>
<li>After quantum expires, the process is preempted and added to the end of the ready queue</li>
</ul>
</li>
<li>$n$ process in ready queue and time quantum is $q$<ul>
<li>Each process get $\frac{1}{n}$ of the CPU time</li>
<li>In chunks of at most $q$ time units</li>
<li><strong>No process waits more than $(n-1)\cdot q$ time units</strong></li>
</ul>
</li>
<li>Performance<ul>
<li>$q$ large → FCFS</li>
<li>$q$ small → Interleaved（交错调度）（Really small → HT，超线程）</li>
<li>$q$ must be large with respect to context switch, otherwise overhead is too high.</li>
</ul>
</li>
<li>How to choose time slices<ul>
<li>What if too big?<ul>
<li>Response time suffers</li>
</ul>
</li>
<li>What if infinite?<ul>
<li>Get back to FCFS</li>
</ul>
</li>
<li>What if too small?<ul>
<li>Through suffers</li>
</ul>
</li>
<li>Actually choices:<ul>
<li>In practice, need to balance short job performance and long job throughput</li>
<li>Typical time slice today is between 10 - 100 ms</li>
<li>Typical context-switching overhead is 0.1 - 1 ms</li>
<li>Roughly 1% overhead due to context-switching</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet2.png"></p>
<h2 id="4-3-Priority-Scheduling"><a href="#4-3-Priority-Scheduling" class="headerlink" title="4.3. Priority Scheduling"></a>4.3. Priority Scheduling</h2><ul>
<li>A priority value (int.) is associated with eachprocess.</li>
<li>Based on:<ul>
<li>Cost to user</li>
<li>Importance to user</li>
<li>Aging</li>
<li>%CPU time used in last XX hours</li>
</ul>
</li>
<li>Execution Plan<ul>
<li>Always execute highest-priority runnable jobs to completion</li>
<li>Each queue can be processed in RR with some time quantum</li>
</ul>
</li>
<li>Problem<ul>
<li>Starvation</li>
<li>Deadlock</li>
</ul>
</li>
<li>How to fix problems<ul>
<li>Dynamic Properties<ul>
<li>Adjust base-level priority up or down based on heuristicsabout interactivity, locking, burst behavior, etc…</li>
</ul>
</li>
</ul>
</li>
<li>How to implement fairness?<ul>
<li>Give each queue some fraction of the CPU</li>
<li>Increase priority of jobs that don’t get service</li>
</ul>
</li>
</ul>
<h2 id="4-4-Lottery-Scheduling"><a href="#4-4-Lottery-Scheduling" class="headerlink" title="4.4. Lottery Scheduling"></a>4.4. Lottery Scheduling</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul>
<li>Give each job some number of lottery tickets</li>
<li>On each time slice, randomly pick a winning ticket</li>
<li>On average, CPU time is proportional to number of tickets given to each job</li>
</ul>
<h3 id="Tickets-Assignment"><a href="#Tickets-Assignment" class="headerlink" title="Tickets Assignment"></a>Tickets Assignment</h3><ul>
<li>SRTF: Short Running Jobs get more, long running jobs get fewer</li>
<li>to avoid starvation, every job gets at least one ticket</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet3.png"></p>
<h3 id="How-to-evaluate-a-scheduling-algorithm"><a href="#How-to-evaluate-a-scheduling-algorithm" class="headerlink" title="How to evaluate a scheduling algorithm?"></a>How to evaluate a scheduling algorithm?</h3><ul>
<li>Deterministic modeling</li>
<li>Queueing models</li>
<li>Implementation &#x2F; Simulation</li>
</ul>
<h2 id="4-6-What-if-We-Knew-the-Future"><a href="#4-6-What-if-We-Knew-the-Future" class="headerlink" title="4.6. What if We Knew the Future?"></a>4.6. What if We Knew the Future?</h2><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><ul>
<li>Shortest Job First (SJF)</li>
<li>Shortest Remaining Time First (SRTF)<ul>
<li>Sometimes called “Shortest Remaining Time to Completion First” (SRTCF)</li>
</ul>
</li>
</ul>
<h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><p>SJF &#x2F; SRTF are the best you can do at minimizing average response time</p>
<ul>
<li><p><strong>Provably optimal</strong> !</p>
</li>
<li><p>SRTF is always at least as good as SJF, we focus on it.</p>
</li>
<li><p>Comparison of SRTF with FCFS</p>
<ul>
<li>What if all jobs the same length?<ul>
<li>SRTF becomes the same as FCFS (i.e. FCFS is best can do if all jobs the same length)</li>
</ul>
</li>
<li>What if jobs have varying length?<ul>
<li>SRTF: short jobs not stuck behind long ones</li>
</ul>
</li>
</ul>
</li>
<li><p>Benefits of SRTF</p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet4.png"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet5.png"></p>
<ul>
<li>Starvation<ul>
<li><strong>SRTF can lead to starvation if many small jobs!</strong></li>
<li>Large jobs never run</li>
</ul>
</li>
<li>Somehow need to predict future<ul>
<li>Some systems ask the user</li>
</ul>
</li>
<li>SRTF Pros &amp; Cons<ul>
<li>Pros: Optimal (average response time)</li>
<li>Cons: Hard to predict future; unfair</li>
</ul>
</li>
</ul>
<h3 id="Predicting-the-length-of-the-next-CPU-burst"><a href="#Predicting-the-length-of-the-next-CPU-burst" class="headerlink" title="Predicting the length of the next CPU burst"></a>Predicting the length of the next CPU burst</h3><ul>
<li>Adaptive: Changing policy based on past behavior<ul>
<li>CPU scheduling, in virtual memory, in file systems, etc</li>
<li>Works because programs have predictable behavior<ul>
<li>If program was I&#x2F;O bound in past, likely in future</li>
<li>If computer behavior were random, wouldn’t help</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-7-Multi-level-Queue"><a href="#4-7-Multi-level-Queue" class="headerlink" title="4.7. Multi-level Queue"></a>4.7. Multi-level Queue</h2><ul>
<li>Ready queue partitioned into separate queues<ul>
<li>e.g. system processes. foreground(interactive), background(batch), student processes…</li>
</ul>
</li>
<li>Each queue has its own scheduling algorithm<ul>
<li>e.g. foreground(RR), background(FCFS)</li>
</ul>
</li>
<li>Processes assigned to one queue permanently</li>
<li>Scheduling must be done between the queues<ul>
<li>Fixed priority</li>
<li>Time slice: Each queue get some CPU time that it schedules</li>
</ul>
</li>
</ul>
<h3 id="Multilevel-Feedback-Queue"><a href="#Multilevel-Feedback-Queue" class="headerlink" title="Multilevel Feedback Queue"></a>Multilevel Feedback Queue</h3><ul>
<li><strong>Multilevel queue, each with different priorities</strong><ul>
<li>Higher priority queue ofter considered “foreground” tasks</li>
</ul>
</li>
<li><strong>Each queue has its own scheduling algorithm</strong><ul>
<li>e.g., Foreground - RR, background - FCFS</li>
</ul>
</li>
<li><strong>A process can move between the queues</strong><ul>
<li>Aging can be implemented this way</li>
</ul>
</li>
<li>Parameters for a multilevel feedback queue scheduler<ul>
<li>Number of queues</li>
<li>Scheduling algorithm for each queue</li>
<li>Method used to determine<ul>
<li>When to upgrade a process</li>
<li>When to demote a process</li>
<li>Which queue a process will enter when that process needs services</li>
</ul>
</li>
</ul>
</li>
<li><strong>Scheduling must be done between the queues</strong><ul>
<li>Fixed priority scheduling</li>
<li>Time slice</li>
<li>Countermeasure: user action that can ruin intent for the OS designers</li>
</ul>
</li>
</ul>
<h3 id="Linux-O-1-Scheduler"><a href="#Linux-O-1-Scheduler" class="headerlink" title="Linux O(1) Scheduler"></a>Linux O(1) Scheduler</h3><p>Priority-based scheduler: 140 priorities</p>
<ul>
<li>40 for User Tasks</li>
<li>100 for Real-time&#x2F;Kernel</li>
<li>Lower priority value → Higher priority</li>
<li>All algorithms $O(1)$: schedule n processes in constant time<ul>
<li>compute time-slices&#x2F;priorities&#x2F;interactivity credits when job finishes time slice</li>
<li>140-bit bit mask indicates presence or absence of job(s) at given priority level</li>
</ul>
</li>
</ul>
<p>Two separate priority queues (arrays)</p>
<ul>
<li>Active</li>
<li>Expired</li>
<li>All tasks in the active queue use up their time slices and get placed on the expired queue, after which queue swapped</li>
</ul>
<p>Time slice depends on priority - linearly mapped onto time slice range</p>
<ul>
<li>Like multi-level queue (one queue per priority) with different time slice at each level</li>
<li>Execution split into “Time slice Granularity” chunks — RR through priority</li>
</ul>
<p>Heuristics</p>
<ul>
<li>User-task priority adjusted ±5 based on heuristics<ul>
<li><code>p -&gt; sleep_avg = sleep_time - run_time</code></li>
<li>Higher <code>sleep_avg</code> → more I&#x2F;O bound the task, more reward</li>
</ul>
</li>
<li>Interactive Credit<ul>
<li>Earned when task sleeps for “long” time, Spend when task runs for “long” time</li>
<li>IC is used to provide hysteresis to avoid changing interactivity for temporary changes in behavior</li>
</ul>
</li>
<li>BUT, interactive tasks get special dispensation<ul>
<li>To try to maintain interactivity</li>
<li>Placed back into active queue, unless another track has starved for too long..</li>
</ul>
</li>
</ul>
<p>Real-Time tasks</p>
<ul>
<li>Always preempt non-RT tasks and no dynamic adjustment of priorities</li>
<li>Scheduling schemes<ul>
<li><code>SCHED_FIFO</code>: preempts other tasks, no timeslice limit</li>
<li><code>SCHED_RR</code>: preempts normal tasks, RR scheduling amongst tasks of same priority</li>
</ul>
</li>
</ul>
<h2 id="4-8-Real-Time-Scheduling"><a href="#4-8-Real-Time-Scheduling" class="headerlink" title="4.8. Real-Time Scheduling"></a>4.8. Real-Time Scheduling</h2><p>Efficiency is important but <strong>predictability</strong> is essential</p>
<ul>
<li>Hard real-time computing<ul>
<li>Attempt to meet all deadlines</li>
<li>EDF (earliest deadline first), LLF (least laxity first)</li>
<li>RMS (Rate-Monotonic Scheduling), DM (Deadline Monotonic Scheduling)</li>
</ul>
</li>
<li>Soft real-time computing<ul>
<li>Attempt to meed deadlines with high probability</li>
<li>Minimize miss ratio &#x2F; Maximize completion ratio</li>
<li>CBS (Constant Bandwidth Server)</li>
</ul>
</li>
</ul>
<h3 id="Issues-in-Real-Time-Scheduling"><a href="#Issues-in-Real-Time-Scheduling" class="headerlink" title="Issues in Real-Time Scheduling"></a>Issues in Real-Time Scheduling</h3><ul>
<li>Dispatch Latency</li>
<li>Priority Inversion and Inheritance<ul>
<li>priority inversion: Higher priority process needs kernel resource currently being used by another lower priority process, thus Higher priority process must wait</li>
<li>Priority inheritance (Solution of Priority inversion): Low priority process now inherits high priority until it has completed use of the resource in question.</li>
</ul>
</li>
</ul>
<h2 id="4-9-EDF-Earliest-Deadline-FIrst"><a href="#4-9-EDF-Earliest-Deadline-FIrst" class="headerlink" title="4.9. EDF (Earliest Deadline FIrst)"></a>4.9. EDF (Earliest Deadline FIrst)</h2><ul>
<li><p>Tasks <strong>periodic</strong> with period $P$ and computation $C$ in each period: $(P_i, C_i)$ for each task $i$</p>
</li>
<li><p>Preemptive priority-based dynamic scheduling:</p>
<ul>
<li>Each task is assigned a (current) priority based on how close the absolute deadline is (i.e. $D^{t+1} &#x3D; D_i^t + P_i$ for each task!)</li>
<li><strong>The scheduler always schedules the active task with the closest absolute deadline</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet6.png"></p>
<ul>
<li>Schedulable when $\sum_{i&#x3D;1}^n(\frac{C_i}{P_i})\leq 1$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet7.png"></p>
<h1 id="5-Address-Translation"><a href="#5-Address-Translation" class="headerlink" title="5. Address Translation"></a>5. Address Translation</h1><h2 id="5-1-Address-Address-Space"><a href="#5-1-Address-Address-Space" class="headerlink" title="5.1. Address &amp; Address Space"></a>5.1. Address &amp; Address Space</h2><p>Definition: Set of accessible addresses and the state associated with them.</p>
<p>What happens when processor reads or writes to an address?</p>
<ul>
<li>Perhaps acts like regular memory</li>
<li>Perhaps causes I&#x2F;O operation (Memory-mapped I&#x2F;O)</li>
<li>Causes program to abort (segfault)?</li>
<li>Communicate with another program</li>
</ul>
<p>Virtualizing Resources：Why worry about Resources？</p>
<p>为什么要担心内存共享？</p>
<ul>
<li>进程和&#x2F;或内核的完整工作状态由其在内存（和寄存器）中的数据定义。</li>
<li>因此，不能让不同的控制线程使用相同的内存。<ul>
<li>物理上：两个不同的数据不能占用内存中的同一个位置。</li>
</ul>
</li>
<li>保护机制。<ul>
<li>不希望不同的线程访问彼此的内存。</li>
</ul>
</li>
</ul>
<h2 id="5-2-Important-Aspects-of-Memory-Multiplexing"><a href="#5-2-Important-Aspects-of-Memory-Multiplexing" class="headerlink" title="5.2. Important Aspects of Memory Multiplexing"></a>5.2. Important Aspects of Memory Multiplexing</h2><h3 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h3><ul>
<li>Prevent access to private memory of other processes<ul>
<li>Different pages of memory can be given special behavior (e.g., Read Only, Invisible to user programs, etc.)</li>
<li>Kernel data protected from user programs</li>
<li>Programs protected from themselves</li>
</ul>
</li>
</ul>
<h3 id="Controlled-Overlap"><a href="#Controlled-Overlap" class="headerlink" title="Controlled Overlap"></a>Controlled Overlap</h3><ul>
<li>Separate state of threads should not collide in physical memory. Obviously, unexpected overlap<br>causes chaos!</li>
<li>Conversely, would like the ability to overlap when desired (for communication)</li>
</ul>
<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><ul>
<li>Ability to translate accesses from one address space (virtual) to a different one (physical)</li>
<li>When translation exists, processor uses virtual addresses, physical memory uses physical<br>addresses</li>
<li>Side effects:<ul>
<li>Can be used to avoid overlap</li>
<li>Can be used to give uniform view of memory to programs</li>
</ul>
</li>
</ul>
<p>Addresses is bounded to final valuesanywhere in this path</p>
<ul>
<li>Depends on HW support</li>
<li>Also depends on OS</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet8.png"></p>
<h2 id="5-3-Simple-B-B-Method"><a href="#5-3-Simple-B-B-Method" class="headerlink" title="5.3. Simple B&amp;B Method"></a>5.3. Simple B&amp;B Method</h2><h3 id="Multi-programming-Version-w-Protection-——Base-Bound"><a href="#Multi-programming-Version-w-Protection-——Base-Bound" class="headerlink" title="Multi-programming (Version w&#x2F; Protection)——Base &amp; Bound"></a>Multi-programming (Version w&#x2F; Protection)——Base &amp; Bound</h3><p>Can we protect programs from each other without translation?</p>
<ul>
<li>Yes: use two special registers BaseAddr and LimitAddr to prevent user from straying outside designated area<ul>
<li>Cause error if user tries to access an illegal address</li>
</ul>
</li>
<li>During switch, kernel loads new base&#x2F;limit from PCB (Process Control Block)</li>
<li>User not allowed to change base&#x2F;limit registers</li>
</ul>
<h3 id="Issue-with-simble-B-B-Method"><a href="#Issue-with-simble-B-B-Method" class="headerlink" title="Issue with simble B&amp;B Method"></a>Issue with simble B&amp;B Method</h3><ul>
<li>Fragmentation problem over time<ul>
<li>Not every process is same size → memory becomes fragmented over time</li>
</ul>
</li>
<li>Missing support for sparse address space<ul>
<li>Would like to have multiple chunks&#x2F;program (Code, Data, Stack, Heap, etc)</li>
</ul>
</li>
<li>Hard to do inter-process sharing<ul>
<li>Want to share code segments when possible</li>
<li>Want to share memory between processes</li>
<li>Helped by providing multiple segments per process</li>
</ul>
</li>
</ul>
<h2 id="5-4-Multi-Segment-Model"><a href="#5-4-Multi-Segment-Model" class="headerlink" title="5.4. Multi Segment Model"></a>5.4. Multi Segment Model</h2><ul>
<li>Segment map resides in processor<ul>
<li><strong>Segment number</strong> mapped into <strong>base&#x2F;limit pair</strong></li>
<li>Base added to offset to generate physical address</li>
<li>Error check catches offset out of range</li>
</ul>
</li>
<li>As many chunks of physical memory as entries<ul>
<li>Segment addressed by portion of virtual address</li>
<li>However, could be included in instruction instead:<ul>
<li>x86 Example: mov [es:bx],ax</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet9.png"></p>
<h3 id="Observations-about-Segmentation"><a href="#Observations-about-Segmentation" class="headerlink" title="Observations about Segmentation"></a>Observations about Segmentation</h3><ul>
<li>Virtual address space has holes<ul>
<li>Segmentation efficient for <strong>sparse address spaces</strong></li>
<li>A correct program should never address gaps (except as mentioned in moment)<ul>
<li>If it does, trap to kernel and dump core</li>
</ul>
</li>
</ul>
</li>
<li>When it is OK to address outside valid range?<ul>
<li>This is how the stack and heap are allowed to grow</li>
<li>For instance, stack takes fault, system automatically increases size of stack</li>
</ul>
</li>
<li>Need protection mode in segment table<ul>
<li>For example, code segment would be read-only</li>
<li><strong>Data and stack</strong> would be <strong>read-write</strong> (stores allowed)</li>
<li>Shared segment could be read-only or read-write</li>
</ul>
</li>
<li>What must be saved&#x2F;restored on context switch?<ul>
<li>Segment table stored in CPU, not in memory (small)</li>
<li>Might store all of process’ memory onto disk when switched (called “<strong>swapping</strong>”)</li>
</ul>
</li>
</ul>
<h3 id="Problems-with-Segmantation"><a href="#Problems-with-Segmantation" class="headerlink" title="Problems with Segmantation"></a>Problems with Segmantation</h3><ul>
<li>Must fit variable-sized chunks into physical memory</li>
<li>May move processes multiple times to fit everything</li>
<li>Limited options for swapping to disk</li>
<li><strong>Fragmentation</strong>: wasted space<ul>
<li>External: free gaps between allocated chunks</li>
<li>Internal: don’t need all memory within allocated chunks</li>
</ul>
</li>
</ul>
<h2 id="5-5-Paging"><a href="#5-5-Paging" class="headerlink" title="5.5. Paging"></a>5.5. Paging</h2><ul>
<li>Physical Memory in <strong>Fixed Size Chunks</strong></li>
<li>Can use simple vector of bits to handle allocation: 00110001110001101 … 110010（BitMap）<ul>
<li>Each bit represents page of physical memory：1 → allocated, 0 → free</li>
</ul>
</li>
<li>Typically have <strong>small pages</strong> (1K-16K)<ul>
<li>Consequently: need multiple pages&#x2F;segment</li>
</ul>
</li>
</ul>
<h3 id="How-to-implement-Simple-Paging"><a href="#How-to-implement-Simple-Paging" class="headerlink" title="How to implement Simple Paging"></a>How to implement Simple Paging</h3><ul>
<li>Page Table (One per process)<ul>
<li>Resides in physical memory</li>
<li>Contains physical page and permission for each virtual page<ul>
<li>Permissions include: Valid bits, Read, Write, etc</li>
</ul>
</li>
</ul>
</li>
<li>Virtual address mapping<ul>
<li>Offset from Virtual address copied to Physical Address<ul>
<li>Example: 10 bit offset fi 1024-byte pages</li>
</ul>
</li>
<li>Virtual page # is all remaining bits<ul>
<li>Example for 32-bits: 32-10 &#x3D; 22 bits, i.e. 4 million entries</li>
<li>Physical page # copied from table into physical address</li>
</ul>
</li>
</ul>
</li>
<li>Check Page Table bounds and permissions</li>
</ul>
<h3 id="Where-is-page-sharing-used"><a href="#Where-is-page-sharing-used" class="headerlink" title="Where is page sharing used ?"></a>Where is page sharing used ?</h3><ul>
<li>The “kernel region” of every process has the same page table entries</li>
<li>Different processes running same binary!</li>
<li>User-level system libraries (execute only)</li>
<li>Shared-memory segments between different processes</li>
</ul>
<h3 id="Some-Simple-Security-Measures"><a href="#Some-Simple-Security-Measures" class="headerlink" title="Some Simple Security Measures"></a>Some Simple Security Measures</h3><ul>
<li>Address Space Randomization</li>
<li>Kernel address space isolation</li>
</ul>
<h2 id="5-6-Multi-Level-Translation"><a href="#5-6-Multi-Level-Translation" class="headerlink" title="5.6. Multi-Level Translation"></a>5.6. Multi-Level Translation</h2><p>Motivation：单层 Page Table 太大了，全部放在memory里很不方便。</p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet10.png"></p>
<h1 id="6-Caching-TLB"><a href="#6-Caching-TLB" class="headerlink" title="6. Caching, TLB"></a>6. Caching, TLB</h1><h2 id="6-1-Page-Table-Page-Table-Entry"><a href="#6-1-Page-Table-Page-Table-Entry" class="headerlink" title="6.1. Page Table &amp; Page Table Entry"></a>6.1. Page Table &amp; Page Table Entry</h2><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet11.png"></p>
<h3 id="Two-level-page-table"><a href="#Two-level-page-table" class="headerlink" title="Two-level page table"></a>Two-level page table</h3><ul>
<li>Tree Of Page Tables: 10b-10b-12b pattern</li>
<li>Table Fixed Size（1024 Entries）<ul>
<li>On Context-Switch: Save single PageTablePtr Register</li>
</ul>
</li>
<li>Valid bits on Page Table Entries<ul>
<li>Don’t need every 2nd-level table</li>
<li>Even when exist, 2nd-level tables <strong>can reside on disk</strong> if not in use</li>
</ul>
</li>
</ul>
<h3 id="Page-Table-Entry（PTE）"><a href="#Page-Table-Entry（PTE）" class="headerlink" title="Page Table Entry（PTE）"></a>Page Table Entry（PTE）</h3><p>Example：x86 PTE</p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet12.png"></p>
<ul>
<li>P: Present (same as “valid” bit in other architectures)</li>
<li>W: Writeable</li>
<li>U: User accessible</li>
<li>PWT: Page write transparent: external cache write-through</li>
<li>PCD: Page cache disabled (page cannot be cached)</li>
<li>A: Accessed: page has been accessed recently</li>
<li>D: Dirty (PTE only): page has been modified recently</li>
<li>PS: Page Size: PS&#x3D;1 → 4MB page (directory only).</li>
<li>Bottom 22 bits of virtual address serve as offset</li>
</ul>
<h3 id="How-to-use-PTE"><a href="#How-to-use-PTE" class="headerlink" title="How to use PTE?"></a>How to use PTE?</h3><ol>
<li>Demand Paging<ul>
<li>Keep only active pages in memory</li>
<li>Place others on disk and mark their PTEs invalid</li>
</ul>
</li>
<li>Copy on Write<ul>
<li>UNIX fork gives copy of parent address space to child<ul>
<li>Address spaces disconnected after child created</li>
</ul>
</li>
<li>How to do this cheaply?<ul>
<li>Make copy of parent’s page tables (point at same memory)</li>
<li><strong>Mark entries in both sets of page tables as read-only</strong></li>
<li><strong>Page fault on write creates two copies（只在需要 Write 的时候，再创建新的页面）</strong></li>
</ul>
</li>
</ul>
</li>
<li>Zero Fill On Demand<ul>
<li>New data pages must carry no information (say be zeroed)</li>
<li>Mark PTEs as invalid; page fault on use gets zeroed page</li>
<li>Often, OS creates zeroed pages in background</li>
</ul>
</li>
</ol>
<h3 id="Multi-level-Translation-Segments-Pages"><a href="#Multi-level-Translation-Segments-Pages" class="headerlink" title="Multi-level Translation: Segments + Pages"></a>Multi-level Translation: Segments + Pages</h3><p>What about a tree of tables?</p>
<ul>
<li>Lowest level page table fi memory still allocated with bitmap</li>
<li>Higher levels often segmented</li>
</ul>
<h2 id="6-2-Inverted-Page-Table"><a href="#6-2-Inverted-Page-Table" class="headerlink" title="6.2. Inverted Page Table"></a>6.2. Inverted Page Table</h2><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet13.png"></p>
<p>IA64: 64bit addresses: Six-level page table?</p>
<ul>
<li>No! Too slow! Too Many Almost-Empty Tables</li>
<li>核心问题：Physical memory may be much less than Virtual Memory allocated</li>
</ul>
<h3 id="Inverted-Page-Table"><a href="#Inverted-Page-Table" class="headerlink" title="Inverted Page Table"></a>Inverted Page Table</h3><p>Using a hash table</p>
<ul>
<li>Called an “<strong>Inverted Page Table</strong>”</li>
<li>Size is <strong>independent of virtual address space</strong></li>
<li>Directly related to amount of physical memory</li>
<li>Very attractive option for 64-bit address spaces<ul>
<li>PowerPC, UltraSPARC, IA64</li>
</ul>
</li>
</ul>
<h2 id="6-3-Address-Translation-Comparison"><a href="#6-3-Address-Translation-Comparison" class="headerlink" title="6.3. Address Translation Comparison"></a>6.3. Address Translation Comparison</h2><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet14.png"></p>
<p>MMU（内存管理单元）的位置和功能。</p>
<p>MMU是位于处理器和内存系统之间的一个组件。当处理器发出读取虚拟地址的请求时，请求会通过MMU转发到缓存（再传递到内存）。一段时间后，内存系统会以物理地址的形式回复存储在该物理地址上的数据（这是通过虚拟地址到物理地址的转换得到的结果）。这个过程在缓存命中时非常快速，但在缓存未命中时会比较慢。</p>
<p>那么MMU具体在做什么呢？在每次引用（指令获取、加载、存储）时，MMU会读取（多层级的）页表项，以获取物理帧或发生错误（FAULT）。这个过程会经过缓存再传递到内存，并且最终会读取或写入到物理位置上。</p>
<p>简而言之，MMU的主要功能是实现虚拟地址到物理地址的转换。它通过查找页表来确定虚拟地址对应的物理地址，并将数据从物理地址读取或写入。这个过程中会使用缓存来提高访问速度，但如果在缓存中未找到对应的数据，则需要从内存中读取，这会比较慢。</p>
<p>总结一下，MMU的作用是管理虚拟地址和物理地址之间的转换，并通过读取和写入物理位置来实现对内存的访问。它是处理器和内存系统之间的重要桥梁，对于实现高效的内存管理至关重要。</p>
<h2 id="6-4-TLB-Translation-Look-Aside-Buffer"><a href="#6-4-TLB-Translation-Look-Aside-Buffer" class="headerlink" title="6.4. TLB: Translation Look-Aside Buffer"></a>6.4. TLB: Translation Look-Aside Buffer</h2><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet15.png"></p>
<h3 id="What-TLB-Organization-Makes-Sense"><a href="#What-TLB-Organization-Makes-Sense" class="headerlink" title="What TLB Organization Makes Sense?"></a>What TLB Organization Makes Sense?</h3><ul>
<li>Needs to be really fast<ul>
<li><strong>Critical path of memory access</strong><ul>
<li>In simplest view: before the cache</li>
<li>Thus, this adds to access time (reducing cache speed)</li>
</ul>
</li>
<li>Seems to argue for Direct Mapped or Low Associativity</li>
</ul>
</li>
<li>However, needs to have very few conflicts!<ul>
<li>With TLB, the Miss Time extremely high! (PT traversal)</li>
<li>Cost of Conflict (Miss Time) is high</li>
<li>Hit Time – dictated by clock cycle</li>
</ul>
</li>
<li>Thrashing: continuous conflicts between accesses</li>
</ul>
<h3 id="Current-Example-Memory-Hierarchy"><a href="#Current-Example-Memory-Hierarchy" class="headerlink" title="Current Example: Memory Hierarchy"></a>Current Example: Memory Hierarchy</h3><p>Caches (all 64 B line size)</p>
<ul>
<li>L1 I-Cache: 32 KiB&#x2F;core, 8-way set assoc.</li>
<li>L1 D Cache: 32 KiB&#x2F;core, 8-way set assoc., 4-5 cycles load-to-use, Writeback policy</li>
<li>L2 Cache: 1 MiB&#x2F;core, 16-way set assoc., Inclusive, Write-back policy, 14 cycles latency</li>
<li>L3 Cache: 1.375 MiB&#x2F;core, 11-way set assoc., shared across cores, Noninclusive victim cache, Write-back policy, 50-70 cycles latency</li>
</ul>
<p>TLB</p>
<ul>
<li>L1 ITLB, 128 entries; 8-way set assoc. for 4 KB pages<ul>
<li>8 entries per thread; fully associative, for 2 MiB &#x2F; 4 MiB page</li>
</ul>
</li>
<li>L1 DTLB 64 entries; 4-way set associative for 4 KB pages<ul>
<li>32 entries; 4-way set associative, 2 MiB &#x2F; 4 MiB page translations:</li>
<li>4 entries; 4-way associative, 1G page translations:</li>
</ul>
</li>
<li>L2 STLB: 1536 entries; 12-way set assoc. 4 KiB + 2 MiB pages<ul>
<li>16 entries; 4-way set associative, 1 GiB page translations:</li>
</ul>
</li>
</ul>
<h3 id="What-Happens-on-a-Context-Switch"><a href="#What-Happens-on-a-Context-Switch" class="headerlink" title="What Happens on a Context Switch?"></a>What Happens on a Context Switch?</h3><ul>
<li>Invalidate TLB: simple but might be expensive<ul>
<li>What if switching frequently between processes</li>
</ul>
</li>
<li>Include ProcessID in TLB<ul>
<li>This is an architectural solution: needs <strong>hardware</strong></li>
</ul>
</li>
</ul>
<p>What if translation tables change?</p>
<ul>
<li>For example, to move page from memory to disk or vice versa…<ul>
<li>Must invalidate TLB entry!</li>
<li>Otherwise, might think that page is still in memory!</li>
</ul>
</li>
<li>Called “<strong>TLB Consistency</strong>”</li>
</ul>
<h1 id="7-Demand-Paging"><a href="#7-Demand-Paging" class="headerlink" title="7. Demand Paging"></a>7. Demand Paging</h1><h2 id="7-1-Page-Fault"><a href="#7-1-Page-Fault" class="headerlink" title="7.1. Page Fault"></a>7.1. Page Fault</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><p>The Virtual-to-Physical Translation fails</p>
<ul>
<li>PTE marked invalid, Priv. Level Violation, Access violation, or does not exist<ul>
<li>Causes an Fault &#x2F; Trap</li>
</ul>
</li>
<li><strong>Not an interrupt</strong> because synchronous to instruction execution<ul>
<li>May occur on instruction fetch or data access</li>
<li>Protection violations typically terminate the instruction</li>
</ul>
</li>
</ul>
<h3 id="Page-Fault-→-Demand-Paging"><a href="#Page-Fault-→-Demand-Paging" class="headerlink" title="Page Fault → Demand Paging"></a>Page Fault → Demand Paging</h3><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet16.png"></p>
<h3 id="Inversion-of-HW-SW-Boundary"><a href="#Inversion-of-HW-SW-Boundary" class="headerlink" title="Inversion of HW&#x2F;SW Boundary"></a>Inversion of HW&#x2F;SW Boundary</h3><p>硬件和软件边界的反转现象：在执行指令时，如果发生页面错误（Page Fault），操作系统的软件会介入并采取相应的措施来解决问题。这可能包括加载页面、创建页面、写时复制等操作，并更新页表项以确保后续的地址转换成功。然后，操作系统会重新启动或恢复指令的执行。这种反转现象在RISC（精简指令集计算机）指令集中是一个巨大的简化，但在x86指令集等复杂指令集中可能会更加复杂，因为指令可能会修改状态。</p>
<h2 id="7-2-Demand-Paging"><a href="#7-2-Demand-Paging" class="headerlink" title="7.2. Demand Paging"></a>7.2. Demand Paging</h2><ul>
<li>What “block size”? - 1 page (e.g, 4 KB)</li>
<li>What “organization” ie. direct-mapped, set-assoc., fullyassociative?<ul>
<li>Any page in any frame of memory,</li>
<li>i.e., fully associative: arbitrary virtual → physical mapping</li>
</ul>
</li>
<li>How do we locate a page?<ul>
<li>First check TLB, then page-table traversal</li>
</ul>
</li>
<li>What is page replacement policy? (i.e. LRU, Random…)<ul>
<li>This requires more explanation… (kinda LRU)</li>
</ul>
</li>
<li>What happens on a miss?<ul>
<li>Go to lower level to fill miss (i.e. disk)</li>
</ul>
</li>
<li>What happens on a write? (write-through, write back)<ul>
<li>Definitely write-back – need dirty bit!</li>
</ul>
</li>
</ul>
<p><img src="/Cheatsheet-Final%20a3ede0b2d25945df9dd63986f8a9b2fb/Untitled%2017.png" alt="Use main memory as “cache” for disk"></p>
<p>Use main memory as “cache” for disk</p>
<h2 id="7-3-Illusion-of-Infinite-Memory"><a href="#7-3-Illusion-of-Infinite-Memory" class="headerlink" title="7.3. Illusion of Infinite Memory"></a>7.3. Illusion of Infinite Memory</h2><p>Transparent Level of Indirection (page table)</p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet18.png"></p>
<h2 id="7-4-Demand-Paging-Mechanisms"><a href="#7-4-Demand-Paging-Mechanisms" class="headerlink" title="7.4. Demand Paging Mechanisms"></a>7.4. Demand Paging Mechanisms</h2><p>PTE makes demand paging implementatable</p>
<ul>
<li>Valid → Page in memory, PTE points at physical page</li>
<li>Not Valid → Page not in memory; use info in PTE to find it on disk when necessary</li>
</ul>
<h3 id="What-does-OS-do-on-a-Page-Fault"><a href="#What-does-OS-do-on-a-Page-Fault" class="headerlink" title="What does OS do on a Page Fault"></a>What does OS do on a Page Fault</h3><p>Choose an old page to replace</p>
<ul>
<li>If old page modified (“D&#x3D;1”), write contents back to disk</li>
<li>Change its PTE and any cached TLB to be invalid</li>
<li>Load new page into memory from disk</li>
<li>Update page table entry, invalidate TLB for new entry</li>
<li>Continue thread from original faulting location</li>
</ul>
<p>TLB for new page will be loaded when thread continued!</p>
<h3 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions"></a>Some Questions</h3><p>During a page fault, where does the OS get a free frame?</p>
<ul>
<li>Keeps a free list<ul>
<li>Unix runs a “reaper” if memory gets too full<ul>
<li>Schedule dirty pages to be written back on disk</li>
<li>Zero (clean) pages which haven’t been accessed in a while</li>
</ul>
</li>
<li>As a last resort, evict a dirty page first</li>
</ul>
</li>
<li>How can we organize these mechanisms?<ul>
<li>Work on the replacement policy</li>
</ul>
</li>
<li>How many page frames&#x2F;process?<ul>
<li>Like thread scheduling, need to “schedule” memory resources:<ul>
<li>Utilization? fairness? priority?</li>
</ul>
</li>
<li>Allocation of disk paging bandwidth</li>
</ul>
</li>
</ul>
<p>操作系统通过维护一个空闲列表来管理可用的物理页帧。当内存空间不足时，Unix系统会运行一个“回收器”，将脏页面写回磁盘，并清除一段时间内未被访问的干净页面。作为最后的手段，如果没有空闲的干净页面，操作系统将优先驱逐一个脏页面。为了组织和管理这些机制，需要制定合适的替换策略。</p>
<p>另外，还讨论了每个进程应分配多少个页帧的问题。类似于线程调度，需要对内存资源进行“调度”，考虑利用率、公平性和优先级等因素。此外，还需要合理分配磁盘分页带宽，以满足不同进程的需求。</p>
<h2 id="7-5-Cost-Model"><a href="#7-5-Cost-Model" class="headerlink" title="7.5. Cost Model"></a>7.5. Cost Model</h2><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet19.png"></p>
<h1 id="8-General-I-O"><a href="#8-General-I-O" class="headerlink" title="8. General I&#x2F;O"></a>8. General I&#x2F;O</h1><h2 id="8-1-What-about-I-O"><a href="#8-1-What-about-I-O" class="headerlink" title="8.1. What about I&#x2F;O?"></a>8.1. What about I&#x2F;O?</h2><ul>
<li>Without I&#x2F;O, computers are useless (disembodied brains?)</li>
<li>But… thousands of devices, each slightly different<ul>
<li>How can we <strong>standardize the interfaces to these devices</strong>?</li>
</ul>
</li>
<li>Devices unreliable: media failures and transmission errors<ul>
<li>How can we <strong>make them reliable</strong>?</li>
</ul>
</li>
<li>Devices unpredictable and&#x2F;or slow<ul>
<li>How can we manage them if we don’t know what they will do or how they will perform?</li>
</ul>
</li>
</ul>
<h2 id="8-2-Visualize-IO"><a href="#8-2-Visualize-IO" class="headerlink" title="8.2. Visualize IO"></a>8.2. Visualize IO</h2><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet20.png"></p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet21.png"></p>
<h2 id="8-3-I-O-Design"><a href="#8-3-I-O-Design" class="headerlink" title="8.3. I&#x2F;O Design"></a>8.3. I&#x2F;O Design</h2><h3 id="Operational-Parameters-for-I-O"><a href="#Operational-Parameters-for-I-O" class="headerlink" title="Operational Parameters for I&#x2F;O"></a>Operational Parameters for I&#x2F;O</h3><ul>
<li>Data granularity: Byte vs. Block<ul>
<li>Some devices provide single byte at a time (e.g., keyboard)</li>
<li>Others provide whole blocks (e.g., disks, networks, etc.)</li>
</ul>
</li>
<li>Access pattern: Sequential vs. Random<ul>
<li>Some devices must be accessed sequentially (e.g., tape)</li>
<li>Others can be accessed “randomly” (e.g., disk, cd, etc.)<ul>
<li>Fixed overhead to start transfers</li>
</ul>
</li>
<li>Some devices require continual monitoring</li>
<li>Others generate interrupts when they need service</li>
</ul>
</li>
<li>Transfer Mechanism: Programmed IO and DMA</li>
</ul>
<h3 id="The-goal-of-the-I-O-Subsystem"><a href="#The-goal-of-the-I-O-Subsystem" class="headerlink" title="The goal of the I&#x2F;O Subsystem"></a>The goal of the I&#x2F;O Subsystem</h3><p>Provide Uniform Interfaces, Despite Wide Range of Different Devices</p>
<h3 id="Standard-Interfaces-to-Devices"><a href="#Standard-Interfaces-to-Devices" class="headerlink" title="Standard Interfaces to Devices"></a>Standard Interfaces to Devices</h3><ul>
<li><strong>Block Devices</strong>: e.g. disk drives, tape drives, DVD-ROM<ul>
<li>Access <strong>blocks of data</strong></li>
<li>Commands include <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>seek()</code></li>
<li>Raw I&#x2F;O or file-system access</li>
<li>Memory-mapped file access possible</li>
</ul>
</li>
<li><strong>Character Devices</strong>: e.g. keyboards, mice, serial ports, some USB devices<ul>
<li><strong>Single characters at a time</strong></li>
<li>Commands include <code>get()</code>, <code>put()</code></li>
<li>Libraries layered on top allow line editing</li>
</ul>
</li>
<li><strong>Network Devices</strong>: e.g. Ethernet, Wireless, Bluetooth<ul>
<li>Different enough from block&#x2F;character to have own interface</li>
<li>Unix and Windows include socket interface<ul>
<li>Separates network protocol from network operation</li>
<li>Includes select() functionality</li>
</ul>
</li>
<li>Usage: pipes, FIFOs, streams, queues, mailboxes</li>
</ul>
</li>
</ul>
<h3 id="How-does-User-Deal-with-Timing"><a href="#How-does-User-Deal-with-Timing" class="headerlink" title="How does User Deal with Timing"></a>How does User Deal with Timing</h3><ul>
<li><strong>Blocking Interface</strong>: “Wait”<ul>
<li>When request data (e.g. <code>read()</code> system call), put process to sleep until data is ready</li>
<li>When write data (e.g. <code>write()</code> system call), put process to sleep until device is ready for data</li>
</ul>
</li>
<li><strong>Non-blocking Interface</strong>: “Don’t Wait”<ul>
<li>Returns quickly from read or write request with count of bytes successfully transferred</li>
<li>Read may return nothing, write may write nothing</li>
</ul>
</li>
<li><strong>Asynchronous Interface</strong>: “Tell Me Later”<ul>
<li>When request data, take pointer to user’s buffer, return immediately; later kernel fills buffer and notifies user</li>
<li>When send data, take pointer to user’s buffer, return immediately; later kernel takes data and notifies user</li>
</ul>
</li>
</ul>
<h3 id="Transferring-Data-to-from-Controller"><a href="#Transferring-Data-to-from-Controller" class="headerlink" title="Transferring Data to&#x2F;from Controller"></a>Transferring Data to&#x2F;from Controller</h3><ul>
<li>Programmed I&#x2F;O:<ul>
<li>Each byte transferred via processor in&#x2F;out or load&#x2F;store</li>
<li>Pro: Simple hardware, easy to program</li>
<li>Con: Consumes processor cycles proportional to data size</li>
</ul>
</li>
<li><strong>Direct Memory Access</strong>:<ul>
<li>Give controller access to memory bus</li>
<li>Ask it to transfer data blocks to&#x2F;from memory directly</li>
</ul>
</li>
<li>Sample interaction with DMA controller (from OSC book):</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet22.png"></p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet23.png"></p>
<h3 id="I-O-Device-Notifying-the-OS"><a href="#I-O-Device-Notifying-the-OS" class="headerlink" title="I&#x2F;O Device Notifying the OS"></a>I&#x2F;O Device Notifying the OS</h3><ul>
<li>The OS needs to know when:<ul>
<li>The I&#x2F;O device has completed an operation</li>
<li>The I&#x2F;O operation has encountered an error</li>
</ul>
</li>
<li><strong>I&#x2F;O Interrupt</strong>:<ul>
<li>Device generates an interrupt whenever it needs service</li>
<li>Pro: handles unpredictable events well</li>
<li>Con: interrupts relatively high overhead</li>
</ul>
</li>
<li><strong>Polling</strong>:<ul>
<li>OS periodically checks a device-specific status register<ul>
<li>I&#x2F;O device puts completion information in status register</li>
</ul>
</li>
<li>Pro: low overhead</li>
<li>Con: may waste many cycles on polling if infrequent or unpredictable I&#x2F;O operations</li>
</ul>
</li>
<li>Actual devices combine both polling and interrupts<ul>
<li>For instance – High-bandwidth network adapter:<ul>
<li>Interrupt for first incoming packet</li>
<li>Poll for following packets until hardware queues are empty</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Device-Drivers"><a href="#Device-Drivers" class="headerlink" title="Device Drivers"></a>Device Drivers</h3><ul>
<li><strong>Device Driver</strong>: Device-specific code in the kernel that interacts directly with the device hardware<ul>
<li>Supports a standard, internal interface</li>
<li>Same kernel I&#x2F;O system can interact easily with different device drivers</li>
<li>Special device-specific configuration supported with the ioctl() system call</li>
</ul>
</li>
<li>Device Drivers typically divided into two pieces:<ul>
<li><strong>Top half</strong>: accessed in call path from system calls<ul>
<li>implements a set of <strong>standard, cross-device calls</strong> like open(), close(), read(), write(), ioctl(), strategy()</li>
<li>This is the kernel’s interface to the device driver</li>
<li>Top half will start I&#x2F;O to device, may put thread to sleep until finished</li>
</ul>
</li>
</ul>
</li>
<li><strong>Bottom half</strong>: run as interrupt routine<ul>
<li>Gets input or transfers next block of output</li>
<li>May wake sleeping threads if I&#x2F;O now complete</li>
</ul>
</li>
</ul>
<h1 id="9-File-System"><a href="#9-File-System" class="headerlink" title="9. File System"></a>9. File System</h1><h2 id="9-1-File"><a href="#9-1-File" class="headerlink" title="9.1. File"></a>9.1. File</h2><h3 id="File-Concept"><a href="#File-Concept" class="headerlink" title="File Concept"></a>File Concept</h3><p>Contiguous logical address space</p>
<ul>
<li>OS abstracts from the physical properties of its storage device to define a logical storage unit called file</li>
<li>Persistent</li>
<li>OS maps files to physical devices</li>
</ul>
<p>Types: Data, Program, Documents</p>
<h3 id="File-Structure"><a href="#File-Structure" class="headerlink" title="File Structure"></a>File Structure</h3><ul>
<li>None - sequence of words&#x2F;bytes</li>
<li>Simple record structure</li>
<li>Complex structures</li>
<li>Can simulate last two with first method by inserting appropriate control<br>characters</li>
<li>Who decides? OS &#x2F; Programs</li>
</ul>
<h3 id="File-Attibutes"><a href="#File-Attibutes" class="headerlink" title="File Attibutes"></a>File Attibutes</h3><ul>
<li>Name</li>
<li>Identifier</li>
<li>Type</li>
<li>Location</li>
<li>Size</li>
<li>Protection</li>
<li>Time, Date, User Identification</li>
<li>Information about files are kept in the directory structure, maintained on disk</li>
</ul>
<h3 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h3><ul>
<li>Create</li>
<li>Write</li>
<li>Read</li>
<li>Reposition within file - file seek</li>
<li>Delete</li>
<li>Truncate</li>
<li>Open&#x2F;Close</li>
</ul>
<h2 id="9-2-Directory"><a href="#9-2-Directory" class="headerlink" title="9.2. Directory"></a>9.2. Directory</h2><h3 id="Information-in-a-Device-Directory"><a href="#Information-in-a-Device-Directory" class="headerlink" title="Information in a Device Directory"></a>Information in a Device Directory</h3><ul>
<li>File name</li>
<li>File type</li>
<li>Address or location</li>
<li>Current length</li>
<li>Maximum length</li>
<li>Date created, last accessed, last updated</li>
<li>Owner ID, Protection Information</li>
</ul>
<h3 id="Operations-Performed-on-Directory"><a href="#Operations-Performed-on-Directory" class="headerlink" title="Operations Performed on Directory"></a>Operations Performed on Directory</h3><ul>
<li>Search for a file</li>
<li>Create a file</li>
<li>Delete a file</li>
<li>List a directory</li>
<li>Rename a file</li>
<li>Traverse the file system</li>
</ul>
<h3 id="Directory-Organization"><a href="#Directory-Organization" class="headerlink" title="Directory Organization"></a>Directory Organization</h3><p>Goals: <strong>Efficiency</strong>, <strong>Naming</strong>, <strong>Grouping</strong></p>
<h2 id="9-3-File-System"><a href="#9-3-File-System" class="headerlink" title="9.3. File System"></a>9.3. File System</h2><h3 id="Components-of-a-File-System"><a href="#Components-of-a-File-System" class="headerlink" title="Components of a File System"></a>Components of a File System</h3><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet24.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  File_Name_Offset --Directory--&gt; File_Number_Offset --Index_Structure--&gt; Storage_Block</span><br></pre></td></tr></table></figure>

<ul>
<li>Open performs <strong>Name Resolution</strong><ul>
<li><strong>Translates pathname into a “file number”</strong></li>
<li>Used as an “index” to locate the blocks<ul>
<li>Creates a file descriptor in PCB within kernel</li>
<li>Returns a “handle” (another integer) to user process</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h3><ul>
<li>Basically a hierarchical structure</li>
<li>Each directory entry is a collection of Files &#x2F; Directories(A link to another entries)</li>
<li>Each has a name and attributes<ul>
<li>Files have data</li>
</ul>
</li>
<li>Links (hard links) make it a <strong>DAG</strong>, not just a tree<ul>
<li>Softlinks (aliases) are another name for an entry</li>
</ul>
</li>
</ul>
<aside>
💡 **Example**: How many disk accesses to resolve “/my/book/count”?


<ul>
<li><p>Read in file header for root (fixed spot on disk)</p>
</li>
<li><p>Read in first data block for root</p>
<ul>
<li>Table of file name&#x2F;index pairs. Search linearly – ok since directories typically very small</li>
</ul>
</li>
<li><p>Read in file header for “my”</p>
</li>
<li><p>Read in first data block for “my”; search for “book”</p>
</li>
<li><p>Read in file header for “book”</p>
</li>
<li><p>Read in first data block for “book”; search for “count”</p>
</li>
<li><p>Read in file header for “count”</p>
</aside>
</li>
<li><p><strong>Current working directory</strong>: Per-address-space pointer to a directory (inode) used for resolving file names</p>
</li>
</ul>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><ul>
<li>Named permanent storage</li>
<li>Contains:<ul>
<li>Data<ul>
<li>Blocks on disk somewhere</li>
</ul>
</li>
<li>Metadata (Attributes)<ul>
<li>Owner, size, last opened, …</li>
<li>Access rights<ul>
<li>R, W, X</li>
<li>Owner, Group, Other (in Unix systems)</li>
<li>Access control list in Windows system</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="In-Memory-File-System-Structures"><a href="#In-Memory-File-System-Structures" class="headerlink" title="In-Memory File System Structures"></a>In-Memory File System Structures</h3><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet25.png"></p>
<ul>
<li>Open system call:<ul>
<li>Resolves file name, finds <strong>file control block (inode)</strong></li>
<li>Makes entries in per-process and system-wide tables</li>
<li>Returns index (called “file handle”) in open-file table</li>
</ul>
</li>
<li>Read&#x2F;write system calls:<ul>
<li>Use file handle to locate <strong>inode</strong></li>
<li>Perform appropriate reads or writes</li>
</ul>
</li>
</ul>
<h2 id="9-4-Our-First-FileSystem-FAT"><a href="#9-4-Our-First-FileSystem-FAT" class="headerlink" title="9.4. Our First FileSystem: FAT"></a>9.4. Our First FileSystem: FAT</h2><h3 id="FAT-File-Allication-Table"><a href="#FAT-File-Allication-Table" class="headerlink" title="FAT: File Allication Table"></a>FAT: File Allication Table</h3><ul>
<li>Assume (for now) we have a way to translate a path to a “file number”<ul>
<li>i.e., a directory structure</li>
</ul>
</li>
<li>Disk Storage is a collection of Blocks<ul>
<li>Just hold file data:</li>
<li>offset <code>o = &lt; B, x &gt;</code></li>
</ul>
</li>
<li>E.g.,: <code>file_read 31, &lt; 2, x &gt;</code><ul>
<li>Index into FAT with file number</li>
<li>Follow linked list to block</li>
<li>Read the block from disk into memory</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet26.png"></p>
<h3 id="FAT-Properties"><a href="#FAT-Properties" class="headerlink" title="FAT Properties"></a>FAT Properties</h3><ul>
<li>File is collection of disk blocks</li>
<li>FAT is linked list 1-1 with blocks</li>
<li>File Number is index of root of block list for the file</li>
<li>File offset (<code>o = &lt; B, x &gt;</code>)</li>
<li>Follow list to get block #</li>
<li>Unused blocks → Marked free (no ordering, must scan to find)</li>
<li>E.g. <code>file_write(31, &lt; 3, y &gt;)</code><ul>
<li>Grab free block</li>
<li>Linking them into file</li>
</ul>
</li>
<li>Grow file by allocating free blocks and linking them in</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet27.png"></p>
<h3 id="FAT-Assessment"><a href="#FAT-Assessment" class="headerlink" title="FAT Assessment"></a>FAT Assessment</h3><p>FAT32 (32 instead of 12 bits) used in Windows, USB drives, SD…</p>
<ul>
<li>Where is FAT stored?<ul>
<li>On Disk, on boot cache in memory, second (backup) copy on disk</li>
</ul>
</li>
<li>What happens when you format a disk?<ul>
<li>Zero the blocks, Mark FAT entries “free”</li>
</ul>
</li>
<li>What happens when you quick format a disk?<ul>
<li>Mark all entries in FAT as free</li>
</ul>
</li>
<li>Simple<ul>
<li>Can implement in device firmware</li>
</ul>
</li>
</ul>
<h3 id="FAT-Directories"><a href="#FAT-Directories" class="headerlink" title="FAT Directories"></a>FAT Directories</h3><p>Directory is a file containing <code>&lt;file_name: file_number&gt;</code> mappings</p>
<ul>
<li>Free space for new&#x2F;deleted entries</li>
<li>In FAT: file attributes are kept in directory (!!!)</li>
<li>Each directory is a linked list of entries</li>
</ul>
<p>Where do you find root directory ( “&#x2F;” )?</p>
<ul>
<li><strong>At well-defined place on disk</strong></li>
<li>For FAT, this is at block 2 (there are no blocks 0 or 1)</li>
<li>Remaining directories are accessed via their file_number</li>
</ul>
<h3 id="FAT-Security-Holes"><a href="#FAT-Security-Holes" class="headerlink" title="FAT Security Holes"></a>FAT Security Holes</h3><ul>
<li>FAT has no access rights</li>
<li>FAT has no header in the file blocks</li>
<li>Just gives an index into the FAT to read data</li>
</ul>
<h2 id="9-5-Unix-File-System"><a href="#9-5-Unix-File-System" class="headerlink" title="9.5. Unix File System"></a>9.5. Unix File System</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul>
<li>Original inode format appeared in BSD 4.1<ul>
<li>Berkeley Standard Distribution Unix</li>
<li>Similar structure for Linux Ext2&#x2F;3</li>
</ul>
</li>
<li>File Number is index into inode arrays</li>
<li>Multi-level index structure<ul>
<li>Great for little and large files</li>
<li>Asymmetric tree with fixed sized blocks</li>
</ul>
</li>
<li>Metadata associated with the file<ul>
<li>Rather than in the directory that points to it</li>
</ul>
</li>
<li>UNIX Fast File System (FFS) BSD 4.2 Locality Heuristics:<ul>
<li>Block group placement</li>
<li>Reserve space</li>
</ul>
</li>
<li>Scalable directory structure</li>
</ul>
<h3 id="Inode-Structure"><a href="#Inode-Structure" class="headerlink" title="Inode Structure"></a>Inode Structure</h3><p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet28.png"></p>
<h3 id="UNIX-BSD-4-2-Problem-1"><a href="#UNIX-BSD-4-2-Problem-1" class="headerlink" title="UNIX BSD 4.2 Problem 1"></a>UNIX BSD 4.2 Problem 1</h3><p>When create a file, don’t know how big it will become (in UNIX, most writes are by appending)</p>
<ul>
<li>How much contiguous space do you allocate for a file?</li>
<li>In BSD 4.2, just find some range of free blocks</li>
<li>Put each new file at the front of different range</li>
<li>To expand a file, you first try successive blocks in bitmap, then choose new range of blocks<ul>
<li>Also in BSD 4.2: store files from same directory near each other</li>
</ul>
</li>
</ul>
<h3 id="UNIX-BSD-4-2-Problem-2"><a href="#UNIX-BSD-4-2-Problem-2" class="headerlink" title="UNIX BSD 4.2 Problem 2"></a>UNIX BSD 4.2 Problem 2</h3><p>Missing blocks due to rotational delay</p>
<blockquote>
<p>Issue: Read one block, do processing, and read next block. In meantime, disk has continued turning: missed next block! Need 1 revolution&#x2F;block!</p>
</blockquote>
<ul>
<li>Solution1: Skip sector positioning (“interleaving”)<ul>
<li>Place the blocks from one file on every other block of a track: give time for processing to overlap rotation</li>
<li>Can be done by OS or in modern drives by the disk controller</li>
</ul>
</li>
<li>Solution 2: Read ahead: read next block right after first, even if application hasn’t asked for it yet<ul>
<li>This can be done either by OS (read ahead)</li>
<li>By disk itself (track buffers) - many disk controllers have internal RAM that allows them to read a complete track</li>
</ul>
</li>
</ul>
<h2 id="9-6-Links"><a href="#9-6-Links" class="headerlink" title="9.6. Links"></a>9.6. Links</h2><h3 id="Hard-link"><a href="#Hard-link" class="headerlink" title="Hard link"></a>Hard link</h3><ul>
<li>Sets another directory entry to contain the file number for the file</li>
<li>Creates another name (path) for the file</li>
<li>Each is “first class”</li>
</ul>
<h3 id="Soft-link-or-Symbolic-Link-or-Shortcut"><a href="#Soft-link-or-Symbolic-Link-or-Shortcut" class="headerlink" title="Soft link (or Symbolic Link or Shortcut)"></a>Soft link (or Symbolic Link or Shortcut)</h3><ul>
<li>Directory entry contains the path and name of the file</li>
<li>Map one name to another name</li>
</ul>
<h2 id="9-7-NTFS"><a href="#9-7-NTFS" class="headerlink" title="9.7. NTFS"></a>9.7. NTFS</h2><ul>
<li>New Technology File System (NTFS)<ul>
<li>Default on Microsoft Windows systems</li>
</ul>
</li>
<li><strong>Variable length extents</strong><ul>
<li>Rather than fixed blocks</li>
</ul>
</li>
<li>Everything (almost) is a sequence of <code>attribute:value</code> pairs<ul>
<li>Meta-data and data</li>
</ul>
</li>
<li>Mix direct and indirect freely</li>
<li>Directories organized in <strong>B-tree structure</strong> by default</li>
<li>Master File Table<ul>
<li>Database with Flexible 1KB entries for metadata&#x2F;data</li>
<li>Variable-sized attribute records (data or metadata)</li>
<li>Extend with variable depth tree (non-resident)</li>
</ul>
</li>
<li>Extents – variable length contiguous regions<ul>
<li>Block pointers cover runs of blocks</li>
<li>Similar approach in Linux (ext4)</li>
<li>File create can provide hint as to size of file</li>
</ul>
</li>
<li>journaling for reliability</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet29.png"></p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet30.png"></p>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet31.png"></p>
<h2 id="9-8-Memory-Mapped-Files"><a href="#9-8-Memory-Mapped-Files" class="headerlink" title="9.8. Memory Mapped Files"></a>9.8. Memory Mapped Files</h2><ul>
<li>Traditional I&#x2F;O involves explicit transfers between buffers in process address space to&#x2F; from regions of a file<ul>
<li>This involves multiple copies into caches in memory, plus system calls</li>
</ul>
</li>
<li>What if we could “map” the file directly into an empty region of our address space<ul>
<li>Implicitly “page it in” when we read it</li>
<li>Write it and “eventually” page it out</li>
</ul>
</li>
<li>Executable files are treated this way when we exec the process!!</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HypoxanthineOvO/HypoImager/main/OS_Final_Cheatsheet32.png"></p>
<h2 id="9-9-File-System-Caching"><a href="#9-9-File-System-Caching" class="headerlink" title="9.9. File System Caching"></a>9.9. File System Caching</h2><ul>
<li>Key Idea: Exploit locality by caching data in memory<ul>
<li>Name translations: Mapping from paths → inodes</li>
<li>Disk blocks: Mapping from block address → disk content</li>
</ul>
</li>
<li><strong>Buffer Cache</strong>: Memory used to cache kernel resources, including disk blocks and name translations<ul>
<li>Can contain “dirty” blocks (blocks yet on disk)</li>
</ul>
</li>
<li>Replacement policy? LRU<ul>
<li>Can afford overhead of timestamps for each disk block</li>
<li>Advantages:<ul>
<li>Works very well for name translation</li>
<li>Works well in general as long as memory is big enough to accommodate a host’s working set of files.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>Fails when some application scans through file system, thereby flushing the cache with data used only once</li>
<li>E.g., : <code>find . –exec grep foo &#123;&#125; \;</code></li>
</ul>
</li>
</ul>
</li>
<li>Other Replacement Policies?<ul>
<li>Some systems allow applications to request other policies</li>
<li>E.g., ‘Use Once’:<ul>
<li>File system can discard blocks as soon as they are used</li>
</ul>
</li>
</ul>
</li>
<li>Cache Size: How much memory should the OS allocate to the buffer cache vs virtual memory?<ul>
<li>Too much memory to the file system cache → won’t be able to run many applications at once</li>
<li>Too little memory to file system cache → many applications may run slowly (disk caching not effective)</li>
<li>Solution: <strong>adjust boundary dynamically</strong> so that the disk access rates for paging and file access are balanced</li>
</ul>
</li>
<li>Read Ahead Prefetching: <strong>fetch sequential blocks early</strong><ul>
<li>Key Idea: exploit fact that most common file access is sequential by prefetching subsequent disk blocks ahead of current read request (if they are not already in memory)</li>
<li>Elevator algorithm can efficiently interleave groups of prefetches from<br>concurrent applications</li>
<li>How much to prefetch?<ul>
<li>Too many imposes delays on requests by other applications</li>
<li>Too few causes many seeks (and rotational delays) among concurrent file requests</li>
</ul>
</li>
</ul>
</li>
<li>Delayed Writes: <strong>Writes to files not immediately</strong> sent out to disk<ul>
<li>Instead, <code>write()</code> copies data from user space buffer to kernel buffer (in<br>cache)<ul>
<li>Enabled by presence of buffer cache: can leave written file blocks in cache<br>for a while</li>
<li>If some other application tries to read data before written to disk, file system<br>will read from cache</li>
</ul>
</li>
</ul>
</li>
<li>Flushed to disk periodically (e.g. in UNIX, every 30 sec)</li>
<li>Advantages:<ul>
<li>Disk scheduler can efficiently order lots of requests</li>
<li>Disk allocation algorithm can be run with correct size value for a file</li>
<li>Some files need never get written to disk! (e..g temporary scratch files written<br><code>/tmp</code> often don’t exist for 30 sec)</li>
</ul>
</li>
<li>Disadvantages<ul>
<li>What if system crashes before file has been written out?</li>
<li>Worse yet, what if system crashes before a directory file has been written<br>out? (lose pointer to inode!)</li>
</ul>
</li>
</ul>
<h2 id="9-10-Important-Ilities"><a href="#9-10-Important-Ilities" class="headerlink" title="9.10. Important Ilities"></a>9.10. Important Ilities</h2><ul>
<li><strong>Availability</strong>: the probability that the system can accept and process requests<ul>
<li>Often measured in “nines” of probability. So, a 99.9% probability is considered “3-nines of availability”</li>
<li>Key idea here is independence of failures</li>
</ul>
</li>
<li><strong>Durability</strong>: the ability of a system to recover data despite faults<ul>
<li>This idea is fault tolerance applied to data</li>
<li>Doesn’t necessarily imply availability: information on pyramids was very durable, but could not be accessed until discovery of Rosetta Stone</li>
</ul>
</li>
<li><strong>Reliability</strong>: the ability of a system or component to perform its required functions under stated conditions for a specified period of time (IEEE definition)<ul>
<li>Usually stronger than simply availability: means that the system is not only “up”, but also working correctly</li>
<li>Includes availability, security, fault tolerance&#x2F;durability</li>
<li>Must make sure data survives system crashes, disk crashes, other problems</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/08/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/CS130/Final-Cheatsheet/" data-id="clylj5tf1003nbc956bplfvxw" data-title="【CS130】Final Review" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CourseReview/" rel="tag">CourseReview</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/01/15/%E4%B8%AA%E4%BA%BA%E5%88%9B%E4%BD%9C/%E4%BA%BA%E6%96%87%E8%AF%BE%E8%AE%BA%E6%96%87/%E5%AE%8B%E8%AF%8D%E4%B8%AD%E7%9A%84%E6%84%9F%E6%80%A7%E5%92%8C%E7%90%86%E6%80%A7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          【宋词导读 读书报告】宋词中的感性和理性
        
      </div>
    </a>
  
  
    <a href="/2023/12/31/2023%E5%B9%B4%E8%AF%97%E8%AF%8D%E5%88%9B%E4%BD%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2023 年诗词创作</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Paper-Reading/">Paper Reading</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">常用技术笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%A3%E6%96%87/">散文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/">数字电路设计与实践</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%B7%A5%E7%A8%8B/">工程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E5%AD%A6%E8%AE%BA%E6%96%87/">文学论文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/">本科课程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/CS130/">CS130</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/CS182/">CS182</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/%E6%AF%9B%E6%A6%82/">毛概</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94%E6%80%9D%E8%80%83/">科研思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/">讲座笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%97%E4%B8%8E%E8%AF%8D/">诗与词</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CourseReview/" rel="tag">CourseReview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyPapers/" rel="tag">MyPapers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Neural-Rendering-Architiecture-Hardware-Software-Co-Design/" rel="tag">Neural Rendering, Architiecture, Hardware-Software Co-Design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiance-Fields-Neural-Rendering/" rel="tag">Radiance Fields, Neural Rendering</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/" rel="tag">实用工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" rel="tag">常用技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF-%E4%BB%BF%E7%9C%9F/" rel="tag">数字电路, 仿真</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF-%E4%BB%BF%E7%9C%9F-VCS-Verdi/" rel="tag">数字电路, 仿真, VCS, Verdi,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B2%90%E6%9B%A6%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8CGPU-%E7%94%9F%E6%80%81/" rel="tag">沐曦集成电路，GPU 生态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%AF%E7%89%87/" rel="tag">芯片</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CourseReview/" style="font-size: 20px;">CourseReview</a> <a href="/tags/MyPapers/" style="font-size: 10px;">MyPapers</a> <a href="/tags/Neural-Rendering-Architiecture-Hardware-Software-Co-Design/" style="font-size: 15px;">Neural Rendering, Architiecture, Hardware-Software Co-Design</a> <a href="/tags/Radiance-Fields-Neural-Rendering/" style="font-size: 10px;">Radiance Fields, Neural Rendering</a> <a href="/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">实用工具</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">常用技术</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF-%E4%BB%BF%E7%9C%9F/" style="font-size: 10px;">数字电路, 仿真</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF-%E4%BB%BF%E7%9C%9F-VCS-Verdi/" style="font-size: 10px;">数字电路, 仿真, VCS, Verdi,</a> <a href="/tags/%E6%B2%90%E6%9B%A6%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8CGPU-%E7%94%9F%E6%80%81/" style="font-size: 10px;">沐曦集成电路，GPU 生态</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 20px;">环境配置</a> <a href="/tags/%E8%8A%AF%E7%89%87/" style="font-size: 10px;">芯片</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/30/MyWorks/">Overview Of My Research：我的科研工作一览</a>
          </li>
        
          <li>
            <a href="/2025/06/30/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/Overview/">ShanghaiTech 课程笔记整理</a>
          </li>
        
          <li>
            <a href="/2024/12/31/2024%E5%B9%B4%E8%AF%97%E8%AF%8D%E5%88%9B%E4%BD%9C/">2024 年诗词创作</a>
          </li>
        
          <li>
            <a href="/2024/06/11/%E4%B8%AA%E4%BA%BA%E5%88%9B%E4%BD%9C/%E4%BA%BA%E6%96%87%E8%AF%BE%E8%AE%BA%E6%96%87/%E6%99%BA%E8%83%BD%E7%9A%84%E9%80%86%E6%B5%81%E4%B8%8E%E8%BE%B9%E7%95%8C/">【科技文明通论 期末论文】智能的逆流与边界</a>
          </li>
        
          <li>
            <a href="/2024/05/25/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Marp/">【实用工具】Marp 和 ShanghaiTech Marp 主题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>